package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"entdemo/ent"
	"entdemo/resolvers/generated"
)

// CreateProduct is the resolver for the CreateProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input ent.CreateProductInput) (*ent.Product, error) {
	return ent.FromContext(ctx).Product.Create().SetInput(input).Save(ctx)
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) CreateManyProduct(ctx context.Context, inputs []*ent.CreateProductInput) ([]*ent.Product, error) {
	c := ent.FromContext(ctx)
	builders := make([]*ent.ProductCreate, len(inputs))
	for i := range inputs {
		builders[i] = c.Product.Create().SetInput(*inputs[i])
	}
	Products, err := c.Product.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, err
	}
	return Products, nil
}
func (r *mutationResolver) UpdateProduct(ctx context.Context, where ent.ProductWhereInput, input ent.UpdateProductInput) (*ent.Product, error) {
	context := ent.FromContext(ctx)
	query, err := where.Filter(context.Product.Query())
	if err != nil {
		return nil, err
	}
	target, err := query.Only(ctx)
	if err != nil {
		return nil, err
	}
	res, err := context.Product.UpdateOne(target).SetInput(input).Save(ctx)
	if err != nil {
		return nil, nil
	}
	return res, nil
}
func (r *mutationResolver) DeleteProduct(ctx context.Context, where ent.ProductWhereInput) (*bool, error) {
	context := ent.FromContext(ctx)
	query, err := where.Filter(context.Product.Query())
	if err != nil {
		return nil, err
	}
	target, err := query.Only(ctx)
	if err != nil {
		return nil, err
	}
	if err := context.Product.DeleteOne(target).Exec(ctx); err != nil {
		return nil, err
	}
	res := true
	return &res, nil
}
func (r *mutationResolver) UpdateManyProduct(ctx context.Context, where ent.ProductWhereInput, input ent.UpdateProductInput) (*int, error) {
	context := ent.FromContext(ctx)
	query, err := where.Filter(context.Product.Query())
	if err != nil {
		return nil, err
	}
	Products, err := query.All(ctx)
	if err != nil {
		return nil, err
	}
	res := 0
	for i := range Products {
		if err := context.Product.UpdateOne(Products[i]).SetInput(input).Exec(ctx); err != nil {
			return nil, err
		}
		res++
	}

	return &res, nil
}
func (r *mutationResolver) DeleteManyProduct(ctx context.Context, where ent.ProductWhereInput) (*int, error) {
	context := ent.FromContext(ctx)
	query, err := where.Filter(context.Product.Query())
	if err != nil {
		return nil, err
	}
	Products, err := query.All(ctx)
	if err != nil {
		return nil, err
	}
	res := 0
	for i := range Products {
		if err := context.Product.DeleteOne(Products[i]).Exec(ctx); err != nil {
			return nil, err
		}
		res++
	}

	return &res, nil
}
